/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package net.jawasystems.jawacore;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.jawasystems.jawacore.dataobjects.PlayerDataObject;
import net.jawasystems.jawacore.handlers.ESHandler;
import net.md_5.bungee.api.ChatColor;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

/**
 *
 * @author alexander
 */
public class PlayerManager {
    
    private static final Logger LOGGER = Logger.getLogger("JawaCore][PlayerHandler");
    public static final String NOPLAYERERROR = ChatColor.RED + "> Error: That player is not found or is not online! Try their actual minecraft name instead of nickname.";

    private static final JavaPlugin plugin = JawaCore.plugin;

    private static final HashMap<UUID, PlayerDataObject> playerDataObjects = new HashMap();
    private static final HashMap<String, UUID> nickNameMap = new HashMap();

    private static final HashMap<UUID, PlayerDataObject> offlinePlayerCache = new HashMap();
    private static final HashMap<String, UUID> offlineNickNameMap = new HashMap();
    private static final HashMap<String, UUID> offlineMCNameMap = new HashMap();
    private static final HashMap<LocalDateTime, UUID> offlineCacheAccessTime = new HashMap();

    private static final HashMap<String, UUID> playerDiscordCodes = new HashMap();
    private static final HashMap<UUID, String> playerDiscordCodesReverse = new HashMap();
    
    private static final HashMap<Integer, Boolean> requestSuccess = new HashMap();
    
    /** Map to track users on CrossLink nodes. This will only be used if the server
     * is a controller. Usernames -> UUID
     */
    private static final HashMap<String, HashMap<String, UUID>> crossLinkUsers = new HashMap();
    //Nicks -> Usernames
    private static final HashMap<String, HashMap<String, String>> crossLinkUsersNickNames = new HashMap();

    /**
     * Clear all data contained in this construct. Should be called on shut
     * down.
     */
    public void deconstruct() {
        playerDataObjects.clear();
        nickNameMap.clear();

        offlinePlayerCache.clear();
        offlineNickNameMap.clear();
        offlineCacheAccessTime.clear();
    }

    /**
     * Load a player into the cache. This should be done when a player joins the
     * server.
     *
     * @param player
     * @param pdObject
     */
    public static void addPlayer(Player player, PlayerDataObject pdObject) {
        addPlayer(player.getUniqueId(), pdObject);

    }

    public static void addPlayer(UUID uuid, PlayerDataObject pdObject) {
        playerDataObjects.put(uuid, pdObject);
        nickNameMap.put(pdObject.getPlainNick().toUpperCase().replaceAll(" ", "_"), uuid);
    }
    
    /** Returns if a player's name appears in the player cache, either online or offline.
     * @param name
     * @return 
     */
    public static boolean isPlayerInCache(String name){
        if (JawaCore.debug) LOGGER.log(Level.INFO, "Checking if {0} is cached", name);
        Player target = plugin.getServer().getPlayer(name);
        String formattedName = name.toUpperCase().replaceAll(" ", "_");
        if (JawaCore.debug) LOGGER.log(Level.INFO, "{0} is in chache:{1}", new Object[]{name, String.valueOf(target != null || nickNameMap.containsKey(formattedName) || offlineNickNameMap.containsKey(formattedName) || offlineMCNameMap.containsKey(formattedName))});
        return target != null || nickNameMap.containsKey(formattedName) || offlineNickNameMap.containsKey(formattedName) || offlineMCNameMap.containsKey(formattedName);
    }
    
    /** Request that the ES handler search for and cache the player.
     * @param name the minecraft name of the player to search for
     * @param requestID the request ID generated by the waiting task
     */
    public static void requestCaching(String name, int requestID){
        if (JawaCore.debug) LOGGER.log(Level.INFO, "Request Caching of name:{0} with requestID:{1}", new Object[]{name, requestID});
        ESHandler.findOfflinePlayerAsync(name, requestID);
    }
    
    public static void cacheOfflinePlayer(PlayerDataObject targetPlayer){
        offlineCacheAccessTime.put(LocalDateTime.now(), targetPlayer.getUniqueID());
        offlinePlayerCache.put(targetPlayer.getUniqueID(), targetPlayer);
        offlineNickNameMap.put(targetPlayer.getPlainNick().toUpperCase().replaceAll(" ", "_"), targetPlayer.getUniqueID());
        offlineMCNameMap.put(targetPlayer.getName().toUpperCase().replaceAll(" ", "_"), targetPlayer.getUniqueID());
    }
    
    /** Set the status of the async player data request.
     * @param requestID the ID of the request
     * @param state true if the request succeeded, false if it failed
     */
    public static void setRequestStatus(int requestID, boolean state){
        if (JawaCore.debug) LOGGER.log(Level.INFO, "Request {0} has registered status {1}", new Object[]{requestID, state});
        requestSuccess.put(requestID, state);
    }
    
    /** Get that status of the request. If the request has succeeded this will be true.
     * If the request has failed this will be false. If the request is not complete this
     * will be null.
     * @param requestID the integer of the request
     * @return @nullable true if success, false if failure, null if not yet completed
     */
    public static Boolean getRequestStatus(int requestID){
        return requestSuccess.get(requestID);
    }
    
    /** Clean up once the requester has a response or if the request has been canceled
     * @param requestID 
     */
    public static void completeRequest(int requestID){
        requestSuccess.remove(requestID);
    }

    /**
     * Uncache a player. This should be called when a player disconnects from
     * the server.
     *
     * @param player
     */
    public static void removePlayer(UUID player) {
        //System.out.print("Plain nick: " + playerDataObjects.get(player).getPlainNick().toUpperCase().replaceAll(" ", "_"));
        //System.out.print(nickNameMap);
        if (nickNameMap.containsKey(playerDataObjects.get(player).getPlainNick().toUpperCase().replaceAll(" ", "_"))) {
            nickNameMap.remove(playerDataObjects.get(player).getPlainNick().toUpperCase().replaceAll(" ", "_"));
        }
        playerDataObjects.remove(player);
    }

    /**
     * Returns a player's dataobject. This will begin by converting the input
     * name into full uppercase and replacing spaces with underscores (ex
     * JAWA_MASTER for Jawa Master) This will search the player nick name map.
     * If there is no nick name found then it will attempt to get a bukkit
     * Player with that name. If that returns null it will execute
     * ESHandler.findOfflinePlayer(name, true) and return that data object, if
     * the user is online and found with either name or nick name then the
     * cached playerDataObject will be returned.
     *
     * This way only offline player information requests will call the database.
     *
     * @param name
     * @return
     */
    public static PlayerDataObject getPlayerDataObject(String name) {

        UUID uuid;
        if (nickNameMap.containsKey(name.toUpperCase().replaceAll(" ", "_"))) {
            uuid = nickNameMap.get(name.toUpperCase().replaceAll(" ", "_"));
        } else {
            Player target = plugin.getServer().getPlayer(name);
            if (target == null) {
                return getOfflinePlayer(name);
            } else {
                uuid = target.getUniqueId();
            }
        }

        return playerDataObjects.get(uuid);
    }

    public static PlayerDataObject getPlayerDataObject(UUID uuid) {
        if (playerDataObjects.containsKey(uuid)) {
            return playerDataObjects.get(uuid);
        } else {
            return getOfflinePlayer(uuid);
        }
    }

    public static PlayerDataObject getPlayerDataObject(Player player) {
        return playerDataObjects.get(player.getUniqueId());
    }
    
    /** Get the PlayerFrom the offline cache. null if a player is not cached.
     * @param name
     * @return 
     */
    public static PlayerDataObject getOfflinePlayerFromCache(String name){
        String formattedName = name.toUpperCase().replaceAll(" ", "_");
        //Search offline nick name cache
        if (offlineNickNameMap.containsKey(formattedName)) {
            for (Entry ent : offlineCacheAccessTime.entrySet()) {
                if (ent.getValue().equals(offlineNickNameMap.get(formattedName))) {
                    offlineCacheAccessTime.remove((LocalDateTime) ent.getKey());
                    offlineCacheAccessTime.put(LocalDateTime.now(), offlineNickNameMap.get(formattedName));
                    break;
                }
            }
            return offlinePlayerCache.get(offlineNickNameMap.get(formattedName));
        } 
        //Search offline minecraft name cache
        else {
            for (Entry ent : offlineCacheAccessTime.entrySet()) {
                if (ent.getValue().equals(offlineMCNameMap.get(formattedName))) {
                    offlineCacheAccessTime.remove((LocalDateTime) ent.getKey());
                    offlineCacheAccessTime.put(LocalDateTime.now(), offlineMCNameMap.get(formattedName));
                    break;
                }
            }
            return offlinePlayerCache.get(offlineMCNameMap.get(formattedName));
        }
    }

    /**
     * Finds an offline player and commits the corresponding dataobject to the
     * offline player cache.
     *
     * @param name
     * @return
     */
    private static PlayerDataObject getOfflinePlayer(String name) {
        String formattedName = name.toUpperCase().replaceAll(" ", "_");
        //Search offline nick name cache
        if (offlineNickNameMap.containsKey(formattedName)) {
            for (Entry ent : offlineCacheAccessTime.entrySet()) {
                if (ent.getValue().equals(offlineNickNameMap.get(formattedName))) {
                    offlineCacheAccessTime.remove((LocalDateTime) ent.getKey());
                    offlineCacheAccessTime.put(LocalDateTime.now(), offlineNickNameMap.get(formattedName));
                    break;
                }
            }
            return offlinePlayerCache.get(offlineNickNameMap.get(formattedName));
        } 
        //Search offline minecraft name cache
        else if (offlineMCNameMap.containsKey(formattedName)){
            for (Entry ent : offlineCacheAccessTime.entrySet()) {
                if (ent.getValue().equals(offlineMCNameMap.get(formattedName))) {
                    offlineCacheAccessTime.remove((LocalDateTime) ent.getKey());
                    offlineCacheAccessTime.put(LocalDateTime.now(), offlineMCNameMap.get(formattedName));
                    break;
                }
            }
            return offlinePlayerCache.get(offlineMCNameMap.get(formattedName));
        }
        //Attempt to get from ESHandler FIXME this needs to be removed once everything uses cache requesting
        else {
            PlayerDataObject pdObject = ESHandler.findOfflinePlayer(name);
            if (pdObject != null) {
                //pdObject.loadPlayerBanData();
                offlineCacheAccessTime.put(LocalDateTime.now(), pdObject.getUniqueID());
                offlinePlayerCache.put(pdObject.getUniqueID(), pdObject);
                offlineNickNameMap.put(pdObject.getPlainNick().toUpperCase().replaceAll(" ", "_"), pdObject.getUniqueID());
            }
            return pdObject;
        }

//        if (pdObject != null) {
//            offlinePlayerCache.put(pdObject.getName(), pdObject);
//        }
    }

    private static PlayerDataObject getOfflinePlayer(UUID uuid) {
//        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();
//        multiSearchRequest.add(ESRequestBuilder.buildSearchRequest("players", "_id", uuid.toString()));
//        return ESHandler.runMultiIndexSearch(multiSearchRequest, new PlayerDataObject(uuid));
        return ESHandler.getPlayerData(uuid.toString());
    }

    /**
     * Returns an online player. This method accepts Minecraft names or player
     * Nicknames. This will return null if the player is not resolvable;
     *
     * @param name
     * @return
     */
    public static Player getPlayer(String name) {

        if (nickNameMap.containsKey(name.toUpperCase().replaceAll(" ", "_"))) {
            return Bukkit.getPlayer(nickNameMap.get(name.toUpperCase().replaceAll(" ", "_"))); //Should never be null
        } else {
            Player target = plugin.getServer().getPlayer(name);
            if (target == null) {
                return null;
            } else {
                return target;
            }
        }
    }

    /**
     * Checks if the supplied string is a valid online player nickname or
     * minecraft name. If it is valid this returns true, else this returns
     * false.
     *
     * @param name
     * @return
     */
    public static boolean isValidPlayer(String name) {
        if (nickNameMap.containsKey(name.toUpperCase().replaceAll(" ", "_"))) {
            return true;
        } else {
            Player target = plugin.getServer().getPlayer(name);
            if (target == null) {
                return false;
            } else {
                return true;
            }
        }
    }

//    /**
//     * Retreaves and validates an admin player.
//     *
//     * @param commandSender
//     * @param parsedArguments
//     * @return
//     */
//    public static PlayerDataObject getAdmin(CommandSender commandSender, HashMap<String, String> parsedArguments) {
//        PlayerDataObject admin;
//        if (commandSender instanceof Player) {
//            if (parsedArguments.containsKey("b")) {
//                commandSender.sendMessage(ChatColor.RED + " > Error: The by(-b) flag is only used when working from the console. This will be ignored.");
//            }
//            admin = getPlayerDataObject((Player) commandSender);
//        } else {
//            if (parsedArguments.containsKey("b")) {
//                admin = getPlayerDataObject(parsedArguments.get("b"));
//            } else {
//                System.out.print(ChatColor.RED + " > Error: You must specify a username for yourself with the -b flag! Make sure to use your minecraft name not your nick!");
//                return null;
//            }
//        }
//
//        if (admin == null) {
//            commandSender.sendMessage(ChatColor.RED + " > Error: That admin wasn't found! Try their actual minecraft name instead of nickname.");
//            return null;
//        } else {
//            return admin;
//        }
//
//    }

    public static void generateCleanupTask() {
        Bukkit.getServer().getScheduler().scheduleSyncRepeatingTask(PlayerManager.plugin, new Runnable() {
            @Override
            public void run() {

                //Cleanup offline cached players that havent been accessed in 5 minutes
                int offlineRemoved = 0;
                LocalDateTime now = LocalDateTime.now();
                if (!offlineCacheAccessTime.isEmpty()) {
                    for (Iterator<LocalDateTime> accessTimeKey = offlineCacheAccessTime.keySet().iterator(); accessTimeKey.hasNext();) {
                        LocalDateTime accessTime = accessTimeKey.next();
                        if (now.isBefore(accessTime.plusMinutes(5))) {
                            if (offlinePlayerCache.containsKey(offlineCacheAccessTime.get(accessTime))) { //if key is in the offline cache
                                String nick = offlinePlayerCache.get(offlineCacheAccessTime.get(accessTime)).getPlainNick().toUpperCase().replaceAll(" ", "_");
                                if (offlineNickNameMap.containsKey(nick)) {
                                    offlineNickNameMap.remove(nick);
                                    offlinePlayerCache.remove(offlineCacheAccessTime.get(accessTime));
                                    offlineCacheAccessTime.remove(accessTime);
                                    offlineRemoved++;
                                } else {
                                    clearOfflineCaches();
                                }

                            } else {
                                clearOfflineCaches();
                            }
                        }
                    }
                    //TODO add debug
                    if (JawaCore.debug) {//To shut this thing up
                        Logger.getLogger("JawaCore][PlayerManager][Cleanup Task").log(Level.INFO, "Cleanup completed. {0} players removed from cache.", offlineRemoved);
                    }

//                //Cleanup online player caches that are out of sync (shouldn't happen unless something weird happened)
//                if ((playerDataObjects.size() != nickNameMap.size()) || (playerDataObjects.size() != Bukkit.getServer().getOnlinePlayers().size())) {
//                    for (Player player : Bukkit.getServer().getOnlinePlayers()){
//                        if (player.getUniqueId())
//                    }
//                }
                }
            }
        }, 6000, 6000);
    }

    private static void clearOfflineCaches() {
        Logger.getLogger("JawaCore][PlayerManager][Cleanup Task").log(Level.INFO, " A cache mismatch was found. All offline player caches have been cleared.");
        offlineCacheAccessTime.clear();
        offlineNickNameMap.clear();
        offlinePlayerCache.clear();
    }

    public static void putPlayerCode(String code, UUID uuid) {
        if (playerDiscordCodes.containsValue(uuid)) {
            String cCode = playerDiscordCodesReverse.get(uuid);
            playerDiscordCodes.remove(cCode);
            playerDiscordCodesReverse.remove(uuid);
        }

        playerDiscordCodes.put(code, uuid);
        playerDiscordCodesReverse.put(uuid, code);

        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> {
            if (playerDiscordCodes.containsKey(code)) {
                playerDiscordCodes.remove(code);
            }
            if (playerDiscordCodesReverse.containsKey(uuid) && playerDiscordCodesReverse.get(uuid).equals(code)) {
                playerDiscordCodesReverse.remove(uuid);
                if (playerDataObjects.containsKey(uuid)) {
                    playerDataObjects.get(uuid).sendMessage(ChatColor.RED + "> Your discord code has expired.");
                }
            }
        }, 6000);
    }

    public static void removePlayerCode(String code, UUID uuid) {
        playerDiscordCodes.remove(code);
        playerDiscordCodesReverse.remove(uuid);
    }
    
    public static boolean codeExists(String linkCode){
        return playerDiscordCodes.containsKey(linkCode);
    }
    
    public static UUID getPlayerCodedUUID(String linkCode){
        return playerDiscordCodes.get(linkCode);
    }
    
    /** Update the controller's list of players on various nodes.
     * @param serverName
     * @param uuidMap
     * @param nickMap 
     */
    public static void updateCrossLinkPlayers(String serverName, HashMap<String, UUID> uuidMap, HashMap<String, String> nickMap){
        crossLinkUsers.put(serverName, uuidMap);
        crossLinkUsersNickNames.put(serverName, nickMap);
        if (JawaCore.debug) {
            LOGGER.log(Level.INFO, "Recived {0} users from {1}", new Object[]{uuidMap.size(), serverName});
            LOGGER.log(Level.INFO, "UUID Map: {0}", uuidMap);
            LOGGER.log(Level.INFO, "Nick Map: {0}", nickMap);
        }
    }
    
    public static List<String> getOnlinePlayerList() {
        List<String> tmp = new ArrayList();
        Bukkit.getServer().getOnlinePlayers().forEach((player) -> {
            tmp.add(player.getName());
        });
        return tmp;
    }
    
    /** Install a new player. This will generate the new PlayerDataObject, register the player with
     * the PlayerManager, and call the info PlayerInfoLoaded event.
     * @param player The UUID of the player being installed
     * @param playerName The player name
     * @param ipAddr The IP Address of the player in string form
     */
    public static void installPlayer(UUID player, String playerName, String ipAddr){
       PlayerDataObject pdo = new PlayerDataObject(player, playerName, ipAddr);
       addPlayer(player, pdo);
       pdo.callPlayerInfoLoaded();
    }

}
